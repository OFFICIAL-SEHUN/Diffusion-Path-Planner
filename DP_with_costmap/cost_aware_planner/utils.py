import numpy as np
import matplotlib.pyplot as plt
import os
import matplotlib.cm as cm

class SimpleKalmanFilter:
    """ A simple 1D Kalman Filter for path smoothing. """
    def __init__(self, process_noise, measurement_noise, initial_value=0, initial_estimate_error=1):
        self.q = process_noise
        self.r = measurement_noise
        self.x = initial_value
        self.p = initial_estimate_error

    def update(self, measurement):
        k = self.p / (self.p + self.r)
        self.x = self.x + k * (measurement - self.x)
        self.p = (1 - k) * self.p
        return self.x

def plot_results(costmap, generated_path, true_path, config):
    """
    Generates and displays a plot of the costmap and paths.
    Args:
        costmap (torch.Tensor): The costmap image tensor.
        generated_path (torch.Tensor): The path generated by the diffusion model.
        true_path (torch.Tensor): The optimal path from the dataset for comparison.
        config (dict): Configuration dictionary for parameters like IMG_SIZE. 
    """
    img_size = config['data']['img_size']
    
    # --- Move tensors to CPU and convert to NumPy ---
    costmap_np = costmap.squeeze().cpu().numpy()
    
    gen_path_norm = generated_path.squeeze().cpu().numpy()
    true_path_norm = true_path.squeeze().cpu().numpy()

    # --- De-normalize paths from [-1, 1] to pixel coordinates ---
    gen_path_scaled = (gen_path_norm + 1) / 2 * img_size
    true_path_scaled = (true_path_norm + 1) / 2 * img_size
    
    print("Generated path (pixel coordinates):")
    print(gen_path_scaled)
    
    # --- Apply Kalman Filter Smoothing ---
    kf_x = SimpleKalmanFilter(process_noise=0.01, measurement_noise=0.7, initial_value=gen_path_scaled[0, 0])
    kf_y = SimpleKalmanFilter(process_noise=0.01, measurement_noise=0.7, initial_value=gen_path_scaled[0, 1])
    smoothed_path = np.zeros_like(gen_path_scaled)
    for i in range(len(gen_path_scaled)):
        smoothed_path[i, 0] = kf_x.update(gen_path_scaled[i, 0])
        smoothed_path[i, 1] = kf_y.update(gen_path_scaled[i, 1])
        
    # --- Plotting ---
    plt.figure(figsize=(10, 10))
    
    # 1. Define the desired colormap: low values (0.0) should be bright (yellow).
    cmap = cm.get_cmap('plasma_r').copy()
    cmap.set_bad(color='black')
    masked_costmap = np.ma.masked_invalid(costmap_np)

    # 2. Display the costmap image using this colormap.
    plt.imshow(masked_costmap, cmap=cmap, origin='upper', vmin=0, vmax=1.0)
    
    # Plot original generated path (pre-smoothing)
    plt.plot(gen_path_scaled[:, 1], gen_path_scaled[:, 0], 'k-', linewidth=4, alpha=0.6, label='Original Generated Path')
    
    # Plot the smoothed path
    # plt.plot(smoothed_path[:, 1], smoothed_path[:, 0], 'c-', linewidth=2.5, label='Smoothed Path (Kalman)')
    
    # Plot the ground truth path
    if true_path_scaled.size > 0:
        plt.plot(true_path_scaled[:, 1], true_path_scaled[:, 0], 'r--', alpha=0.8, label='True Path (A*)')

    # Mark start and end points using the more reliable A* path
    if true_path_scaled.size > 0:
        plt.scatter(true_path_scaled[0, 1], true_path_scaled[0, 0], c='purple', marker='o', s=100, label='Start', zorder=5)
        plt.scatter(true_path_scaled[-1, 1], true_path_scaled[-1, 0], c='purple', marker='x', s=100, label='End', zorder=5)
    else: # Fallback to smoothed path if A* fails
        plt.scatter(smoothed_path[0, 1], smoothed_path[0, 0], c='purple', marker='o', s=100, label='Start', zorder=5)
        plt.scatter(smoothed_path[-1, 1], smoothed_path[-1, 0], c='purple', marker='x', s=100, label='End', zorder=5)
    
    plt.legend()
    plt.title("Diffusion Path Planner on Costmap")
    plt.xlim(0, img_size)
    plt.ylim(img_size, 0)
    plt.grid(True, which='both', linestyle='--', linewidth=0.5)
    
    # 3. Create a colorbar that is explicitly managed to ensure correctness.
    norm = plt.Normalize(vmin=0, vmax=1.0)
    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
    sm.set_array([]) # This is needed for the mappable to work.

    # Create the colorbar from the explicit mappable.
    cbar = plt.colorbar(sm, label="Cost")

    # Invert the y-axis to place 0.0 at the top.
    # cbar.ax.invert_yaxis()
    
    # --- Save the Figure ---
    results_dir = 'results'
    if not os.path.exists(results_dir):
        os.makedirs(results_dir)
    plt.savefig(os.path.join(results_dir, 'diffusion_path_plan.png'))
    plt.close() # Close the plot to free up memory
    
    # plt.show() # Disabled for non-interactive saving
